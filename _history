{"entries":[{"timestamp":1731271363532,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"0"],[1,"13"],[0,"\" y=\""],[-1,"0"],[1,"42"],[0,"\"><s"]],"start1":104,"start2":104,"length1":15,"length2":17}]}]},{"timestamp":1731271363532,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"art\""],[-1," id=\"KG3c;ZplT?28kTcIBn3a\""],[0," x=\""]],"start1":100,"start2":100,"length1":34,"length2":8},{"diffs":[[0,"ber\""],[-1," id=\"w%F3=1EPipkI*GGn?[Il\""],[0,"><va"]],"start1":167,"start2":167,"length1":34,"length2":8},{"diffs":[[0,"max\""],[-1," id=\"^{jJN(nT!4$|E,7?-gmS\""],[0,"><mu"]],"start1":219,"start2":219,"length1":34,"length2":8}]}]},{"timestamp":1741372391351,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"n-start\""],[1," id=\"KG3c;ZplT?28kTcIBn3a\""],[0," x=\"0\" y"]],"start1":96,"start2":96,"length1":16,"length2":42},{"diffs":[[0,"_number\""],[1," id=\"w%F3=1EPipkI*GGn?[Il\""],[0,"><value "]],"start1":189,"start2":189,"length1":16,"length2":42},{"diffs":[[0,"_minmax\""],[1," id=\"^{jJN(nT!4$|E,7?-gmS\""],[0,"><mutati"]],"start1":267,"start2":267,"length1":16,"length2":42}]}]},{"timestamp":1741372392115,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"art\""],[-1," id=\"Pe)i7}zlVi6yky70I5=H\""],[0," x=\""]],"start1":100,"start2":100,"length1":34,"length2":8},{"diffs":[[0,"ber\""],[-1," id=\"(6z;]i#sE{oUm/V^5F5h\""],[0,"><va"]],"start1":167,"start2":167,"length1":34,"length2":8},{"diffs":[[0,"max\""],[-1," id=\"8o4Y@ePa9$]NCrQS+VKJ\""],[0,"><mu"]],"start1":219,"start2":219,"length1":34,"length2":8}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":345,"start2":345,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// テストはここに来ます。このパッケージが拡張機能として使用されるときにはコンパイルされません。\n"}]}],"snapshots":[{"timestamp":1731271363531,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"13\" y=\"42\"><statement name=\"HANDLER\"><block type=\"set_bib_number\"><value name=\"bib\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"999\" label=\"Bib\" precision=\"0\"></mutation><field name=\"SLIDER\">25</field></shadow></value></block></statement></block></xml>","main.ts":"","README.md":"","pxt-mbitmbib-extension.json":"{\"README.md\":\"\\n> Open this page at GitHub Pages: [https://jp-96.github.io/pxt-mbitmbib-extension/](https://jp-96.github.io/pxt-mbitmbib-extension/)\\n\\n## Creating Extensions\\n\\nExtensions are PXT’s dynamic/static library mechanism for extending a target, such as the pxt-micro:bit:\\n\\n* [MakeCode extensions](https://makecode.com/extensions)\\n\\n### Use this template\\n\\n* open the repository on github.  \\n[https://github.com/jp-96/pxt-mbitmbib-extension](https://github.com/jp-96/pxt-mbitmbib-extension)\\n* click **Use this template**.  \\n[Here - https://github.com/jp-96/pxt-mbitmbib-extension/generate](https://github.com/jp-96/pxt-mbitmbib-extension/generate)\\n* settings for your new repository.  \\nSettings > Actions > General > Workflow permissions: **Read and write permissions**  \\nSettings > Pages > branch: **master**\\n\\n## Use as Extension\\n\\nThis repository can be added as an **extension** in MakeCode.\\n\\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\\n* click on **New Project**\\n* click on **Extensions** under the gearwheel menu\\n* search for **https://github.com/jp-96/pxt-mbitmbib-extension** and import\\n\\n## Edit this project ![Build status badge](https://github.com/jp-96/pxt-mbitmbib-extension/workflows/MakeCode/badge.svg)\\n\\nTo edit this repository in MakeCode.\\n\\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\\n* click on **Import** then click on **Import URL**\\n* paste **https://github.com/jp-96/pxt-mbitmbib-extension** and click import\\n\\n## Blocks preview\\n\\n<!--\\nThis image shows the blocks code from the last commit in master.\\nThis image may take a few minutes to refresh.\\n\\n![A rendered view of the blocks](https://github.com/jp-96/pxt-mbitmbib-extension/raw/master/.github/makecode/blocks.png)\\n-->\\n![A rendered view of the blocks](https://github.com/jp-96/pxt-mbitmbib-extension/raw/master/.github/statics/blocks.png)\\n\\n\\n### `Example`\\n\\n```blocks\\nMbitMore.setBibNumber(123)\\n\\n```\\n\\n## Downloaded HEX file to Use as Extension\\n\\nReleased HEX file can be imported as an **extension** in MakeCode.\\n\\n* open [https://github.com/jp-96/pxt-mbitmbib-extension/releases](https://github.com/jp-96/pxt-mbitmbib-extension/releases)\\n* download HEX file\\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\\n* click on **New Project**\\n* click on **Extensions** under the gearwheel menu\\n* click on **Import File**\\n* select downloaded HEX file and click on **Go ahead!**\\n\\n\\n#### Metadata (used for search, rendering)\\n\\n* for PXT/microbit\\n\\n<script src=\\\"https://cdn.jsdelivr.net/gh/jp-rad/pxt-ubit-extension@0.5.0/.github/statics/gh-pages-embed.js\\\"></script>\\n<script>makeCodeRender(\\\"{{ site.makecode.home_url }}\\\", [ \\\"custom=github:jp-rad/pxt-ubit-extension\\\", ]);</script>\\n\",\"_locales/ja/pxt-mbitmbib-extension-jsdoc-strings.json\":\"{\\n  \\\"MbitMore.setBibNumber\\\": \\\"背番号の設定\\\"\\n}\",\"_locales/ja/pxt-mbitmbib-extension-strings.json\":\"{\\n  \\\"MbitMore._resetAdvertising|block\\\": \\\"(internal) %gapName %serviceUUID\\\",\\n  \\\"MbitMore.setBibNumber|block\\\": \\\"背番号 %bib\\\",\\n  \\\"MbitMore|block\\\": \\\"MbitMore\\\",\\n  \\\"{id:category}MbitMore\\\": \\\"MbitMore\\\"\\n}\",\"enums.d.ts\":\"// Auto-generated. Do not edit.\\n\\n// Auto-generated. Do not edit. Really.\\n\",\"pxt.json\":\"{\\n    \\\"name\\\": \\\"pxt-mbitmbib-extension\\\",\\n    \\\"version\\\": \\\"0.1.0\\\",\\n    \\\"description\\\": \\\"The device name can be changed to a numbered one for easier identification with the Microbit More editor.\\\",\\n    \\\"dependencies\\\": {\\n        \\\"core\\\": \\\"*\\\",\\n        \\\"pxt-mbit-more-v2\\\": \\\"github:microbit-more/pxt-mbit-more-v2\\\"\\n    },\\n    \\\"files\\\": [\\n        \\\"README.md\\\",\\n        \\\"enums.d.ts\\\",\\n        \\\"shims.d.ts\\\",\\n        \\\"src/custom.ts\\\",\\n        \\\"src/custom.cpp\\\",\\n        \\\"src/customlib.h\\\",\\n        \\\"src/customlib.cpp\\\",\\n        \\\"_locales/ja/pxt-mbitmbib-extension-jsdoc-strings.json\\\",\\n        \\\"_locales/ja/pxt-mbitmbib-extension-strings.json\\\"\\n    ],\\n    \\\"testFiles\\\": [\\n        \\\"test/test.ts\\\"\\n    ],\\n    \\\"targetVersions\\\": {\\n        \\\"target\\\": \\\"6.0.17\\\",\\n        \\\"targetId\\\": \\\"microbit\\\"\\n    },\\n    \\\"supportedTargets\\\": [\\n        \\\"microbit\\\"\\n    ],\\n    \\\"preferredEditor\\\": \\\"tsprj\\\"\\n}\\n\",\"shims.d.ts\":\"// Auto-generated. Do not edit.\\n\\n// Auto-generated. Do not edit. Really.\\n\",\"src/custom.cpp\":\"#include \\\"pxt.h\\\"\\r\\n#include \\\"customlib.h\\\"\\r\\n\\r\\nnamespace MbitMore\\r\\n{\\r\\n    //%\\r\\n    void _resetAdvertising(String gapName, int serviceUUID)\\r\\n    {\\r\\n        customlib::resetAdvertising(MSTR(gapName), (uint16_t)serviceUUID);\\r\\n    }\\r\\n\\r\\n}\\r\\n\",\"src/custom.ts\":\"//% color=#FF9900\\nnamespace MbitMore {\\n    \\n    const CPREFIX_DEVICE_NAME = \\\"BBC micro:bit\\\" // for Microbit More Editor\\n    const CSERVICE_UUID_16 = 61445  // 0xF005 - scratch link\\n\\n    /**\\n     * set bib number.\\n     * @param n bib number\\n     */\\n    //% block=\\\"bib %bib\\\"\\n    //% blockId=set_bib_number\\n    //% bib.min=0 bib.max=999 bib.defl=999\\n    //% weight=100\\n    //% advanced=true\\n    export function setBibNumber(bib: number): void {\\n        let s = \\\"00\\\" + convertToText(Math.imul(Math.abs(bib), 1) % 1000)\\n        s = CPREFIX_DEVICE_NAME + \\\" #\\\" + s.substr(s.length - 3, 3)\\n        _resetAdvertising(s, CSERVICE_UUID_16)\\n    }\\n\\n    //% block=\\\"(internal) %gapName %serviceUUID\\\"\\n    //% shim=MbitMore::_resetAdvertising\\n    //% blockHidden=true\\n    export function _resetAdvertising(gapName: string, serviceUUID: number): void {\\n        console.log(\\\"rename: '\\\" + gapName + \\\"' (\\\" + serviceUUID + \\\")\\\")\\n    }\\n\\n}\\n\",\"src/customlib.cpp\":\"#include \\\"pxt.h\\\"\\n#include \\\"customlib.h\\\"\\n\\nnamespace customlib\\n{\\n\\n#if MICROBIT_CODAL\\n\\n#include \\\"ble_advdata.h\\\"\\n#include \\\"peer_manager.h\\\"\\n\\n    /**\\n     * For configure advertising\\n     *\\n     * https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L133\\n     * https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L134\\n     */\\n    // ********************************************************************************\\n    // static uint8_t              m_adv_handle    = BLE_GAP_ADV_SET_HANDLE_NOT_SET;\\n    static uint8_t m_adv_handle = 0; // ******** WARNING: magic handle number! ********\\n    // ********************************************************************************\\n    static uint8_t m_enc_advdata[BLE_GAP_ADV_SET_DATA_SIZE_MAX];\\n    static uint8_t m_enc_scanrsp[BLE_GAP_ADV_SET_DATA_SIZE_MAX];\\n\\n    // static void microbit_ble_configureAdvertising( bool, bool, bool, uint16_t, int, ble_advdata_t *);\\n    // https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L1187\\n\\n    /**\\n     * Function to configure advertising\\n     *\\n     * @param connectable Choose connectable advertising events.\\n     * @param discoverable Choose LE General Discoverable Mode.\\n     * @param whitelist Filter scan and connect requests with whitelist.\\n     * @param interval_ms Advertising interval in milliseconds.\\n     * @param timeout_seconds Advertising timeout in seconds.\\n     * @param p_advdata advertising data.\\n     * @param p_scanrsp scan responce data.\\n     */\\n    static void custom_microbit_ble_configureAdvertising(bool connectable, bool discoverable, bool whitelist,\\n                                                         uint16_t interval_ms, int timeout_seconds,\\n                                                         ble_advdata_t *p_advdata, ble_advdata_t *p_scanrsp)\\n    {\\n        MICROBIT_DEBUG_DMESG(\\\"configureAdvertising connectable %d, discoverable %d\\\", (int)connectable, (int)discoverable);\\n        MICROBIT_DEBUG_DMESG(\\\"whitelist %d, interval_ms %d, timeout_seconds %d\\\", (int)whitelist, (int)interval_ms, (int)timeout_seconds);\\n\\n        ble_gap_adv_params_t gap_adv_params;\\n        memset(&gap_adv_params, 0, sizeof(gap_adv_params));\\n        gap_adv_params.properties.type = connectable\\n                                             ? BLE_GAP_ADV_TYPE_CONNECTABLE_SCANNABLE_UNDIRECTED\\n                                             : BLE_GAP_ADV_TYPE_NONCONNECTABLE_SCANNABLE_UNDIRECTED;\\n        gap_adv_params.interval = (1000 * interval_ms) / 625; // 625 us units\\n        if (gap_adv_params.interval < BLE_GAP_ADV_INTERVAL_MIN)\\n            gap_adv_params.interval = BLE_GAP_ADV_INTERVAL_MIN;\\n        if (gap_adv_params.interval > BLE_GAP_ADV_INTERVAL_MAX)\\n            gap_adv_params.interval = BLE_GAP_ADV_INTERVAL_MAX;\\n        gap_adv_params.duration = timeout_seconds * 100; // 10 ms units\\n        gap_adv_params.filter_policy = whitelist\\n                                           ? BLE_GAP_ADV_FP_FILTER_BOTH\\n                                           : BLE_GAP_ADV_FP_ANY;\\n        gap_adv_params.primary_phy = BLE_GAP_PHY_1MBPS;\\n\\n        ble_gap_adv_data_t gap_adv_data;\\n        memset(&gap_adv_data, 0, sizeof(gap_adv_data));\\n        gap_adv_data.adv_data.p_data = m_enc_advdata;\\n        gap_adv_data.adv_data.len = BLE_GAP_ADV_SET_DATA_SIZE_MAX;\\n        MICROBIT_BLE_ECHK(ble_advdata_encode(p_advdata, gap_adv_data.adv_data.p_data, &gap_adv_data.adv_data.len));\\n        // NRF_LOG_HEXDUMP_INFO( gap_adv_data.adv_data.p_data, gap_adv_data.adv_data.len);\\n        gap_adv_data.scan_rsp_data.p_data = m_enc_scanrsp;\\n        gap_adv_data.scan_rsp_data.len = BLE_GAP_ADV_SET_DATA_SIZE_MAX;\\n        MICROBIT_BLE_ECHK(ble_advdata_encode(p_scanrsp, gap_adv_data.scan_rsp_data.p_data, &gap_adv_data.scan_rsp_data.len));\\n        // NRF_LOG_HEXDUMP_INFO( gap_adv_data.scan_rsp_data.p_data, gap_adv_data.scan_rsp_data.len);\\n        MICROBIT_BLE_ECHK(sd_ble_gap_adv_set_configure(&m_adv_handle, &gap_adv_data, &gap_adv_params));\\n    }\\n\\n    // Setup advertising.\\n    // https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L478\\n\\n    // static void microbit_ble_configureAdvertising( bool, bool, bool, uint16_t, int, ble_uuid_t *)\\n    // https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L1218\\n\\n    void resetAdvertising(const ManagedString &gapName, const uint16_t serviceUUID)\\n    {\\n        // Stop\\n        uBit.bleManager.stopAdvertising();\\n\\n        // [Advertising] Complete local name\\n        ble_gap_conn_sec_mode_t sec_mode;\\n        memset(&sec_mode, 0, sizeof(sec_mode));\\n        BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);\\n        MICROBIT_BLE_ECHK(sd_ble_gap_device_name_set(&sec_mode, (const uint8_t *)gapName.toCharArray(), gapName.length()));\\n\\n        // [Scan Response] Complete list of 16-bit Service IDs.\\n        static ble_uuid_t uuid;\\n        uuid.type = BLE_UUID_TYPE_BLE;\\n        uuid.uuid = serviceUUID;\\n\\n        // Configure\\n        bool connectable = true;\\n        bool discoverable = true;\\n        bool whitelist = false;\\n\\n#if CONFIG_ENABLED(MICROBIT_BLE_WHITELIST)\\n        // Configure a whitelist to filter all connection requetss from unbonded devices.\\n        // Most BLE stacks only permit one connection at a time, so this prevents denial of service attacks.\\n        //    ble->gap().setScanningPolicyMode(Gap::SCAN_POLICY_IGNORE_WHITELIST);\\n        //    ble->gap().setAdvertisingPolicyMode(Gap::ADV_POLICY_FILTER_CONN_REQS);\\n\\n        pm_peer_id_t peer_list[MICROBIT_BLE_MAXIMUM_BONDS];\\n        uint32_t list_size = MICROBIT_BLE_MAXIMUM_BONDS;\\n        MICROBIT_BLE_ECHK(pm_peer_id_list(peer_list, &list_size, PM_PEER_ID_INVALID, PM_PEER_ID_LIST_ALL_ID));\\n        // MICROBIT_BLE_ECHK( pm_whitelist_set( list_size ? peer_list : NULL, list_size));\\n        // MICROBIT_BLE_ECHK( pm_device_identities_list_set( list_size ? peer_list : NULL, list_size));\\n        connectable = discoverable = whitelist = list_size > 0;\\n        MICROBIT_DEBUG_DMESG(\\\"whitelist size = %d\\\", list_size);\\n#endif\\n\\n        // adv_data\\n        ble_advdata_t advdata;\\n        memset(&advdata, 0, sizeof(advdata));\\n        advdata.name_type = BLE_ADVDATA_FULL_NAME;\\n        advdata.flags = !whitelist && discoverable\\n                            ? BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED | BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE\\n                            : BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;\\n        // scan_rsp_data\\n        ble_advdata_t scanrsp;\\n        memset(&scanrsp, 0, sizeof(scanrsp));\\n        // advdata.name_type = BLE_ADVDATA_NO_NAME;\\n        scanrsp.uuids_complete.p_uuids = &uuid;\\n        scanrsp.uuids_complete.uuid_cnt = 1;\\n        // configure\\n        custom_microbit_ble_configureAdvertising(connectable, discoverable, whitelist,\\n                                                 MICROBIT_BLE_ADVERTISING_INTERVAL, MICROBIT_BLE_ADVERTISING_TIMEOUT,\\n                                                 &advdata, &scanrsp);\\n\\n        // Restart\\n        uBit.bleManager.advertise();\\n    }\\n\\n#else // MICROBIT_CODAL\\n\\n    void resetAdvertising(const ManagedString &gapName, const uint16_t serviceUUID)\\n    {\\n        uBit.ble->stopAdvertising();\\n        // [Advertising] Complete local name\\n        uBit.ble->accumulateAdvertisingPayload(GapAdvertisingData::COMPLETE_LOCAL_NAME, (uint8_t *)gapName.toCharArray(), gapName.length());\\n        // [Scan Response] Complete list of 16-bit Service IDs.\\n        uBit.ble->accumulateScanResponse(GapAdvertisingData::COMPLETE_LIST_16BIT_SERVICE_IDS, (uint8_t *)&serviceUUID, 2);\\n        uBit.ble->startAdvertising();\\n    }\\n\\n#endif // MICROBIT_CODAL\\n}\\n\",\"src/customlib.h\":\"#ifndef CUSTOMLIB_H\\n#define CUSTOMLIB_H\\n\\n#include \\\"pxt.h\\\"\\n\\nnamespace customlib\\n{\\n    void resetAdvertising(const ManagedString &gapName, const uint16_t serviceUUID);\\n}\\n\\n#endif // #ifndef CUSTOMLIB_H\\n\",\"test/test.ts\":\"/**\\n * tests go here; this will not be compiled when this package is used as an extension.\\n */\\nMbitMore.setBibNumber(123)\\n\"}","pxt.json":"{\n    \"name\": \"mbib extension of mbit-more-v2 extension\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-mbitmbib-extension\": \"pkg:pxt-mbitmbib-extension.json\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"pxt-mbitmbib-extension.json\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v7.0.51\",\n        \"tag\": \"v7.0.51\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/c3819f016bd720d0eb86efea9a84dcd4fc7b2e1f\",\n        \"target\": \"7.0.51\",\n        \"pxt\": \"11.1.5\"\n    },\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1741372391351,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"set_bib_number\"><value name=\"bib\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"999\" label=\"Bib\" precision=\"0\"></mutation><field name=\"SLIDER\">25</field></shadow></value></block></statement></block></xml>","main.ts":"","README.md":"","pxt-mbitmbib-extension.json":"{\"README.md\":\"\\n> Open this page at GitHub Pages: [https://jp-96.github.io/pxt-mbitmbib-extension/](https://jp-96.github.io/pxt-mbitmbib-extension/)\\n\\n## Creating Extensions\\n\\nExtensions are PXT’s dynamic/static library mechanism for extending a target, such as the pxt-micro:bit:\\n\\n* [MakeCode extensions](https://makecode.com/extensions)\\n\\n### Use this template\\n\\n* open the repository on github.  \\n[https://github.com/jp-96/pxt-mbitmbib-extension](https://github.com/jp-96/pxt-mbitmbib-extension)\\n* click **Use this template**.  \\n[Here - https://github.com/jp-96/pxt-mbitmbib-extension/generate](https://github.com/jp-96/pxt-mbitmbib-extension/generate)\\n* settings for your new repository.  \\nSettings > Actions > General > Workflow permissions: **Read and write permissions**  \\nSettings > Pages > branch: **master**\\n\\n## Use as Extension\\n\\nThis repository can be added as an **extension** in MakeCode.\\n\\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\\n* click on **New Project**\\n* click on **Extensions** under the gearwheel menu\\n* search for **https://github.com/jp-96/pxt-mbitmbib-extension** and import\\n\\n## Edit this project ![Build status badge](https://github.com/jp-96/pxt-mbitmbib-extension/workflows/MakeCode/badge.svg)\\n\\nTo edit this repository in MakeCode.\\n\\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\\n* click on **Import** then click on **Import URL**\\n* paste **https://github.com/jp-96/pxt-mbitmbib-extension** and click import\\n\\n## Blocks preview\\n\\n<!--\\nThis image shows the blocks code from the last commit in master.\\nThis image may take a few minutes to refresh.\\n\\n![A rendered view of the blocks](https://github.com/jp-96/pxt-mbitmbib-extension/raw/master/.github/makecode/blocks.png)\\n-->\\n![A rendered view of the blocks](https://github.com/jp-96/pxt-mbitmbib-extension/raw/master/.github/statics/blocks.png)\\n\\n\\n### `Example`\\n\\n```blocks\\nMbitMore.setBibNumber(123)\\n\\n```\\n\\n## Downloaded HEX file to Use as Extension\\n\\nReleased HEX file can be imported as an **extension** in MakeCode.\\n\\n* open [https://github.com/jp-96/pxt-mbitmbib-extension/releases](https://github.com/jp-96/pxt-mbitmbib-extension/releases)\\n* download HEX file\\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\\n* click on **New Project**\\n* click on **Extensions** under the gearwheel menu\\n* click on **Import File**\\n* select downloaded HEX file and click on **Go ahead!**\\n\\n\\n#### Metadata (used for search, rendering)\\n\\n* for PXT/microbit\\n\\n<script src=\\\"https://cdn.jsdelivr.net/gh/jp-rad/pxt-ubit-extension@0.5.0/.github/statics/gh-pages-embed.js\\\"></script>\\n<script>makeCodeRender(\\\"{{ site.makecode.home_url }}\\\", [ \\\"custom=github:jp-rad/pxt-ubit-extension\\\", ]);</script>\\n\",\"_locales/ja/pxt-mbitmbib-extension-jsdoc-strings.json\":\"{\\n  \\\"MbitMore.setBibNumber\\\": \\\"背番号の設定\\\"\\n}\",\"_locales/ja/pxt-mbitmbib-extension-strings.json\":\"{\\n  \\\"MbitMore._resetAdvertising|block\\\": \\\"(internal) %gapName %serviceUUID\\\",\\n  \\\"MbitMore.setBibNumber|block\\\": \\\"背番号 %bib\\\",\\n  \\\"MbitMore|block\\\": \\\"MbitMore\\\",\\n  \\\"{id:category}MbitMore\\\": \\\"MbitMore\\\"\\n}\",\"enums.d.ts\":\"// Auto-generated. Do not edit.\\n\\n// Auto-generated. Do not edit. Really.\\n\",\"pxt.json\":\"{\\n    \\\"name\\\": \\\"pxt-mbitmbib-extension\\\",\\n    \\\"version\\\": \\\"0.1.0\\\",\\n    \\\"description\\\": \\\"The device name can be changed to a numbered one for easier identification with the Microbit More editor.\\\",\\n    \\\"dependencies\\\": {\\n        \\\"core\\\": \\\"*\\\",\\n        \\\"pxt-mbit-more-v2\\\": \\\"github:microbit-more/pxt-mbit-more-v2\\\"\\n    },\\n    \\\"files\\\": [\\n        \\\"README.md\\\",\\n        \\\"enums.d.ts\\\",\\n        \\\"shims.d.ts\\\",\\n        \\\"src/custom.ts\\\",\\n        \\\"src/custom.cpp\\\",\\n        \\\"src/customlib.h\\\",\\n        \\\"src/customlib.cpp\\\",\\n        \\\"_locales/ja/pxt-mbitmbib-extension-jsdoc-strings.json\\\",\\n        \\\"_locales/ja/pxt-mbitmbib-extension-strings.json\\\"\\n    ],\\n    \\\"testFiles\\\": [\\n        \\\"test/test.ts\\\"\\n    ],\\n    \\\"targetVersions\\\": {\\n        \\\"target\\\": \\\"6.0.17\\\",\\n        \\\"targetId\\\": \\\"microbit\\\"\\n    },\\n    \\\"supportedTargets\\\": [\\n        \\\"microbit\\\"\\n    ],\\n    \\\"preferredEditor\\\": \\\"tsprj\\\"\\n}\\n\",\"shims.d.ts\":\"// Auto-generated. Do not edit.\\n\\n// Auto-generated. Do not edit. Really.\\n\",\"src/custom.cpp\":\"#include \\\"pxt.h\\\"\\r\\n#include \\\"customlib.h\\\"\\r\\n\\r\\nnamespace MbitMore\\r\\n{\\r\\n    //%\\r\\n    void _resetAdvertising(String gapName, int serviceUUID)\\r\\n    {\\r\\n        customlib::resetAdvertising(MSTR(gapName), (uint16_t)serviceUUID);\\r\\n    }\\r\\n\\r\\n}\\r\\n\",\"src/custom.ts\":\"//% color=#FF9900\\nnamespace MbitMore {\\n    \\n    const CPREFIX_DEVICE_NAME = \\\"BBC micro:bit\\\" // for Microbit More Editor\\n    const CSERVICE_UUID_16 = 61445  // 0xF005 - scratch link\\n\\n    /**\\n     * set bib number.\\n     * @param n bib number\\n     */\\n    //% block=\\\"bib %bib\\\"\\n    //% blockId=set_bib_number\\n    //% bib.min=0 bib.max=999 bib.defl=999\\n    //% weight=100\\n    //% advanced=true\\n    export function setBibNumber(bib: number): void {\\n        let s = \\\"00\\\" + convertToText(Math.imul(Math.abs(bib), 1) % 1000)\\n        s = CPREFIX_DEVICE_NAME + \\\" #\\\" + s.substr(s.length - 3, 3)\\n        _resetAdvertising(s, CSERVICE_UUID_16)\\n    }\\n\\n    //% block=\\\"(internal) %gapName %serviceUUID\\\"\\n    //% shim=MbitMore::_resetAdvertising\\n    //% blockHidden=true\\n    export function _resetAdvertising(gapName: string, serviceUUID: number): void {\\n        console.log(\\\"rename: '\\\" + gapName + \\\"' (\\\" + serviceUUID + \\\")\\\")\\n    }\\n\\n}\\n\",\"src/customlib.cpp\":\"#include \\\"pxt.h\\\"\\n#include \\\"customlib.h\\\"\\n\\nnamespace customlib\\n{\\n\\n#if MICROBIT_CODAL\\n\\n#include \\\"ble_advdata.h\\\"\\n#include \\\"peer_manager.h\\\"\\n\\n    /**\\n     * For configure advertising\\n     *\\n     * https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L133\\n     * https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L134\\n     */\\n    // ********************************************************************************\\n    // static uint8_t              m_adv_handle    = BLE_GAP_ADV_SET_HANDLE_NOT_SET;\\n    static uint8_t m_adv_handle = 0; // ******** WARNING: magic handle number! ********\\n    // ********************************************************************************\\n    static uint8_t m_enc_advdata[BLE_GAP_ADV_SET_DATA_SIZE_MAX];\\n    static uint8_t m_enc_scanrsp[BLE_GAP_ADV_SET_DATA_SIZE_MAX];\\n\\n    // static void microbit_ble_configureAdvertising( bool, bool, bool, uint16_t, int, ble_advdata_t *);\\n    // https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L1187\\n\\n    /**\\n     * Function to configure advertising\\n     *\\n     * @param connectable Choose connectable advertising events.\\n     * @param discoverable Choose LE General Discoverable Mode.\\n     * @param whitelist Filter scan and connect requests with whitelist.\\n     * @param interval_ms Advertising interval in milliseconds.\\n     * @param timeout_seconds Advertising timeout in seconds.\\n     * @param p_advdata advertising data.\\n     * @param p_scanrsp scan responce data.\\n     */\\n    static void custom_microbit_ble_configureAdvertising(bool connectable, bool discoverable, bool whitelist,\\n                                                         uint16_t interval_ms, int timeout_seconds,\\n                                                         ble_advdata_t *p_advdata, ble_advdata_t *p_scanrsp)\\n    {\\n        MICROBIT_DEBUG_DMESG(\\\"configureAdvertising connectable %d, discoverable %d\\\", (int)connectable, (int)discoverable);\\n        MICROBIT_DEBUG_DMESG(\\\"whitelist %d, interval_ms %d, timeout_seconds %d\\\", (int)whitelist, (int)interval_ms, (int)timeout_seconds);\\n\\n        ble_gap_adv_params_t gap_adv_params;\\n        memset(&gap_adv_params, 0, sizeof(gap_adv_params));\\n        gap_adv_params.properties.type = connectable\\n                                             ? BLE_GAP_ADV_TYPE_CONNECTABLE_SCANNABLE_UNDIRECTED\\n                                             : BLE_GAP_ADV_TYPE_NONCONNECTABLE_SCANNABLE_UNDIRECTED;\\n        gap_adv_params.interval = (1000 * interval_ms) / 625; // 625 us units\\n        if (gap_adv_params.interval < BLE_GAP_ADV_INTERVAL_MIN)\\n            gap_adv_params.interval = BLE_GAP_ADV_INTERVAL_MIN;\\n        if (gap_adv_params.interval > BLE_GAP_ADV_INTERVAL_MAX)\\n            gap_adv_params.interval = BLE_GAP_ADV_INTERVAL_MAX;\\n        gap_adv_params.duration = timeout_seconds * 100; // 10 ms units\\n        gap_adv_params.filter_policy = whitelist\\n                                           ? BLE_GAP_ADV_FP_FILTER_BOTH\\n                                           : BLE_GAP_ADV_FP_ANY;\\n        gap_adv_params.primary_phy = BLE_GAP_PHY_1MBPS;\\n\\n        ble_gap_adv_data_t gap_adv_data;\\n        memset(&gap_adv_data, 0, sizeof(gap_adv_data));\\n        gap_adv_data.adv_data.p_data = m_enc_advdata;\\n        gap_adv_data.adv_data.len = BLE_GAP_ADV_SET_DATA_SIZE_MAX;\\n        MICROBIT_BLE_ECHK(ble_advdata_encode(p_advdata, gap_adv_data.adv_data.p_data, &gap_adv_data.adv_data.len));\\n        // NRF_LOG_HEXDUMP_INFO( gap_adv_data.adv_data.p_data, gap_adv_data.adv_data.len);\\n        gap_adv_data.scan_rsp_data.p_data = m_enc_scanrsp;\\n        gap_adv_data.scan_rsp_data.len = BLE_GAP_ADV_SET_DATA_SIZE_MAX;\\n        MICROBIT_BLE_ECHK(ble_advdata_encode(p_scanrsp, gap_adv_data.scan_rsp_data.p_data, &gap_adv_data.scan_rsp_data.len));\\n        // NRF_LOG_HEXDUMP_INFO( gap_adv_data.scan_rsp_data.p_data, gap_adv_data.scan_rsp_data.len);\\n        MICROBIT_BLE_ECHK(sd_ble_gap_adv_set_configure(&m_adv_handle, &gap_adv_data, &gap_adv_params));\\n    }\\n\\n    // Setup advertising.\\n    // https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L478\\n\\n    // static void microbit_ble_configureAdvertising( bool, bool, bool, uint16_t, int, ble_uuid_t *)\\n    // https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L1218\\n\\n    void resetAdvertising(const ManagedString &gapName, const uint16_t serviceUUID)\\n    {\\n        // Stop\\n        uBit.bleManager.stopAdvertising();\\n\\n        // [Advertising] Complete local name\\n        ble_gap_conn_sec_mode_t sec_mode;\\n        memset(&sec_mode, 0, sizeof(sec_mode));\\n        BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);\\n        MICROBIT_BLE_ECHK(sd_ble_gap_device_name_set(&sec_mode, (const uint8_t *)gapName.toCharArray(), gapName.length()));\\n\\n        // [Scan Response] Complete list of 16-bit Service IDs.\\n        static ble_uuid_t uuid;\\n        uuid.type = BLE_UUID_TYPE_BLE;\\n        uuid.uuid = serviceUUID;\\n\\n        // Configure\\n        bool connectable = true;\\n        bool discoverable = true;\\n        bool whitelist = false;\\n\\n#if CONFIG_ENABLED(MICROBIT_BLE_WHITELIST)\\n        // Configure a whitelist to filter all connection requetss from unbonded devices.\\n        // Most BLE stacks only permit one connection at a time, so this prevents denial of service attacks.\\n        //    ble->gap().setScanningPolicyMode(Gap::SCAN_POLICY_IGNORE_WHITELIST);\\n        //    ble->gap().setAdvertisingPolicyMode(Gap::ADV_POLICY_FILTER_CONN_REQS);\\n\\n        pm_peer_id_t peer_list[MICROBIT_BLE_MAXIMUM_BONDS];\\n        uint32_t list_size = MICROBIT_BLE_MAXIMUM_BONDS;\\n        MICROBIT_BLE_ECHK(pm_peer_id_list(peer_list, &list_size, PM_PEER_ID_INVALID, PM_PEER_ID_LIST_ALL_ID));\\n        // MICROBIT_BLE_ECHK( pm_whitelist_set( list_size ? peer_list : NULL, list_size));\\n        // MICROBIT_BLE_ECHK( pm_device_identities_list_set( list_size ? peer_list : NULL, list_size));\\n        connectable = discoverable = whitelist = list_size > 0;\\n        MICROBIT_DEBUG_DMESG(\\\"whitelist size = %d\\\", list_size);\\n#endif\\n\\n        // adv_data\\n        ble_advdata_t advdata;\\n        memset(&advdata, 0, sizeof(advdata));\\n        advdata.name_type = BLE_ADVDATA_FULL_NAME;\\n        advdata.flags = !whitelist && discoverable\\n                            ? BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED | BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE\\n                            : BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;\\n        // scan_rsp_data\\n        ble_advdata_t scanrsp;\\n        memset(&scanrsp, 0, sizeof(scanrsp));\\n        // advdata.name_type = BLE_ADVDATA_NO_NAME;\\n        scanrsp.uuids_complete.p_uuids = &uuid;\\n        scanrsp.uuids_complete.uuid_cnt = 1;\\n        // configure\\n        custom_microbit_ble_configureAdvertising(connectable, discoverable, whitelist,\\n                                                 MICROBIT_BLE_ADVERTISING_INTERVAL, MICROBIT_BLE_ADVERTISING_TIMEOUT,\\n                                                 &advdata, &scanrsp);\\n\\n        // Restart\\n        uBit.bleManager.advertise();\\n    }\\n\\n#else // MICROBIT_CODAL\\n\\n    void resetAdvertising(const ManagedString &gapName, const uint16_t serviceUUID)\\n    {\\n        uBit.ble->stopAdvertising();\\n        // [Advertising] Complete local name\\n        uBit.ble->accumulateAdvertisingPayload(GapAdvertisingData::COMPLETE_LOCAL_NAME, (uint8_t *)gapName.toCharArray(), gapName.length());\\n        // [Scan Response] Complete list of 16-bit Service IDs.\\n        uBit.ble->accumulateScanResponse(GapAdvertisingData::COMPLETE_LIST_16BIT_SERVICE_IDS, (uint8_t *)&serviceUUID, 2);\\n        uBit.ble->startAdvertising();\\n    }\\n\\n#endif // MICROBIT_CODAL\\n}\\n\",\"src/customlib.h\":\"#ifndef CUSTOMLIB_H\\n#define CUSTOMLIB_H\\n\\n#include \\\"pxt.h\\\"\\n\\nnamespace customlib\\n{\\n    void resetAdvertising(const ManagedString &gapName, const uint16_t serviceUUID);\\n}\\n\\n#endif // #ifndef CUSTOMLIB_H\\n\",\"test/test.ts\":\"/**\\n * tests go here; this will not be compiled when this package is used as an extension.\\n */\\nMbitMore.setBibNumber(123)\\n\"}","pxt.json":"{\n    \"name\": \"mbib extension of mbit-more-v2 extension\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-mbitmbib-extension\": \"pkg:pxt-mbitmbib-extension.json\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"pxt-mbitmbib-extension.json\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v7.0.51\",\n        \"tag\": \"v7.0.51\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/c3819f016bd720d0eb86efea9a84dcd4fc7b2e1f\",\n        \"target\": \"7.0.51\",\n        \"pxt\": \"11.1.5\"\n    },\n    \"preferredEditor\": \"blocksprj\"\n}\n"}}],"shares":[],"lastSaveTime":1741372425317}