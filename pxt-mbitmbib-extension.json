{"README.md":"\n> Open this page at GitHub Pages: [https://jp-96.github.io/pxt-mbitmbib-extension/](https://jp-96.github.io/pxt-mbitmbib-extension/)\n\n## Creating Extensions\n\nExtensions are PXT’s dynamic/static library mechanism for extending a target, such as the pxt-micro:bit:\n\n* [MakeCode extensions](https://makecode.com/extensions)\n\n### Use this template\n\n* open the repository on github.  \n[https://github.com/jp-96/pxt-mbitmbib-extension](https://github.com/jp-96/pxt-mbitmbib-extension)\n* click **Use this template**.  \n[Here - https://github.com/jp-96/pxt-mbitmbib-extension/generate](https://github.com/jp-96/pxt-mbitmbib-extension/generate)\n* settings for your new repository.  \nSettings > Actions > General > Workflow permissions: **Read and write permissions**  \nSettings > Pages > branch: **master**\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/jp-96/pxt-mbitmbib-extension** and import\n\n## Edit this project ![Build status badge](https://github.com/jp-96/pxt-mbitmbib-extension/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/jp-96/pxt-mbitmbib-extension** and click import\n\n## Blocks preview\n\n<!--\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/jp-96/pxt-mbitmbib-extension/raw/master/.github/makecode/blocks.png)\n-->\n![A rendered view of the blocks](https://github.com/jp-96/pxt-mbitmbib-extension/raw/master/.github/statics/blocks.png)\n\n\n### `Example`\n\n```blocks\nMbitMore.setBibNumber(123)\n\n```\n\n## Downloaded HEX file to Use as Extension\n\nReleased HEX file can be imported as an **extension** in MakeCode.\n\n* open [https://github.com/jp-96/pxt-mbitmbib-extension/releases](https://github.com/jp-96/pxt-mbitmbib-extension/releases)\n* download HEX file\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* click on **Import File**\n* select downloaded HEX file and click on **Go ahead!**\n\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n\n<script src=\"https://cdn.jsdelivr.net/gh/jp-rad/pxt-ubit-extension@0.5.0/.github/statics/gh-pages-embed.js\"></script>\n<script>makeCodeRender(\"{{ site.makecode.home_url }}\", [ \"custom=github:jp-rad/pxt-ubit-extension\", ]);</script>\n","_locales/ja/pxt-mbitmbib-extension-jsdoc-strings.json":"{\n  \"MbitMore.setBibNumber\": \"背番号の設定\"\n}","_locales/ja/pxt-mbitmbib-extension-strings.json":"{\n  \"MbitMore._resetAdvertising|block\": \"(internal) %gapName %serviceUUID\",\n  \"MbitMore.setBibNumber|block\": \"背番号 %bib\",\n  \"MbitMore|block\": \"MbitMore\",\n  \"{id:category}MbitMore\": \"MbitMore\"\n}","enums.d.ts":"// Auto-generated. Do not edit.\n\n// Auto-generated. Do not edit. Really.\n","pxt.json":"{\n    \"name\": \"pxt-mbitmbib-extension\",\n    \"version\": \"0.1.0\",\n    \"description\": \"The device name can be changed to a numbered one for easier identification with the Microbit More editor.\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"pxt-mbit-more-v2\": \"github:microbit-more/pxt-mbit-more-v2\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"src/custom.ts\",\n        \"src/custom.cpp\",\n        \"src/customlib.h\",\n        \"src/customlib.cpp\",\n        \"_locales/ja/pxt-mbitmbib-extension-jsdoc-strings.json\",\n        \"_locales/ja/pxt-mbitmbib-extension-strings.json\"\n    ],\n    \"testFiles\": [\n        \"test/test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"6.0.17\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","shims.d.ts":"// Auto-generated. Do not edit.\n\n// Auto-generated. Do not edit. Really.\n","src/custom.cpp":"#include \"pxt.h\"\r\n#include \"customlib.h\"\r\n\r\nnamespace MbitMore\r\n{\r\n    //%\r\n    void _resetAdvertising(String gapName, int serviceUUID)\r\n    {\r\n        customlib::resetAdvertising(MSTR(gapName), (uint16_t)serviceUUID);\r\n    }\r\n\r\n}\r\n","src/custom.ts":"//% color=#FF9900\nnamespace MbitMore {\n    \n    const CPREFIX_DEVICE_NAME = \"BBC micro:bit\" // for Microbit More Editor\n    const CSERVICE_UUID_16 = 61445  // 0xF005 - scratch link\n\n    /**\n     * set bib number.\n     * @param n bib number\n     */\n    //% block=\"bib %bib\"\n    //% blockId=set_bib_number\n    //% bib.min=0 bib.max=999 bib.defl=999\n    //% weight=100\n    //% advanced=true\n    export function setBibNumber(bib: number): void {\n        let s = \"00\" + convertToText(Math.imul(Math.abs(bib), 1) % 1000)\n        s = CPREFIX_DEVICE_NAME + \" #\" + s.substr(s.length - 3, 3)\n        _resetAdvertising(s, CSERVICE_UUID_16)\n    }\n\n    //% block=\"(internal) %gapName %serviceUUID\"\n    //% shim=MbitMore::_resetAdvertising\n    //% blockHidden=true\n    export function _resetAdvertising(gapName: string, serviceUUID: number): void {\n        console.log(\"rename: '\" + gapName + \"' (\" + serviceUUID + \")\")\n    }\n\n}\n","src/customlib.cpp":"#include \"pxt.h\"\n#include \"customlib.h\"\n\nnamespace customlib\n{\n\n#if MICROBIT_CODAL\n\n#include \"ble_advdata.h\"\n#include \"peer_manager.h\"\n\n    /**\n     * For configure advertising\n     *\n     * https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L133\n     * https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L134\n     */\n    // ********************************************************************************\n    // static uint8_t              m_adv_handle    = BLE_GAP_ADV_SET_HANDLE_NOT_SET;\n    static uint8_t m_adv_handle = 0; // ******** WARNING: magic handle number! ********\n    // ********************************************************************************\n    static uint8_t m_enc_advdata[BLE_GAP_ADV_SET_DATA_SIZE_MAX];\n    static uint8_t m_enc_scanrsp[BLE_GAP_ADV_SET_DATA_SIZE_MAX];\n\n    // static void microbit_ble_configureAdvertising( bool, bool, bool, uint16_t, int, ble_advdata_t *);\n    // https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L1187\n\n    /**\n     * Function to configure advertising\n     *\n     * @param connectable Choose connectable advertising events.\n     * @param discoverable Choose LE General Discoverable Mode.\n     * @param whitelist Filter scan and connect requests with whitelist.\n     * @param interval_ms Advertising interval in milliseconds.\n     * @param timeout_seconds Advertising timeout in seconds.\n     * @param p_advdata advertising data.\n     * @param p_scanrsp scan responce data.\n     */\n    static void custom_microbit_ble_configureAdvertising(bool connectable, bool discoverable, bool whitelist,\n                                                         uint16_t interval_ms, int timeout_seconds,\n                                                         ble_advdata_t *p_advdata, ble_advdata_t *p_scanrsp)\n    {\n        MICROBIT_DEBUG_DMESG(\"configureAdvertising connectable %d, discoverable %d\", (int)connectable, (int)discoverable);\n        MICROBIT_DEBUG_DMESG(\"whitelist %d, interval_ms %d, timeout_seconds %d\", (int)whitelist, (int)interval_ms, (int)timeout_seconds);\n\n        ble_gap_adv_params_t gap_adv_params;\n        memset(&gap_adv_params, 0, sizeof(gap_adv_params));\n        gap_adv_params.properties.type = connectable\n                                             ? BLE_GAP_ADV_TYPE_CONNECTABLE_SCANNABLE_UNDIRECTED\n                                             : BLE_GAP_ADV_TYPE_NONCONNECTABLE_SCANNABLE_UNDIRECTED;\n        gap_adv_params.interval = (1000 * interval_ms) / 625; // 625 us units\n        if (gap_adv_params.interval < BLE_GAP_ADV_INTERVAL_MIN)\n            gap_adv_params.interval = BLE_GAP_ADV_INTERVAL_MIN;\n        if (gap_adv_params.interval > BLE_GAP_ADV_INTERVAL_MAX)\n            gap_adv_params.interval = BLE_GAP_ADV_INTERVAL_MAX;\n        gap_adv_params.duration = timeout_seconds * 100; // 10 ms units\n        gap_adv_params.filter_policy = whitelist\n                                           ? BLE_GAP_ADV_FP_FILTER_BOTH\n                                           : BLE_GAP_ADV_FP_ANY;\n        gap_adv_params.primary_phy = BLE_GAP_PHY_1MBPS;\n\n        ble_gap_adv_data_t gap_adv_data;\n        memset(&gap_adv_data, 0, sizeof(gap_adv_data));\n        gap_adv_data.adv_data.p_data = m_enc_advdata;\n        gap_adv_data.adv_data.len = BLE_GAP_ADV_SET_DATA_SIZE_MAX;\n        MICROBIT_BLE_ECHK(ble_advdata_encode(p_advdata, gap_adv_data.adv_data.p_data, &gap_adv_data.adv_data.len));\n        // NRF_LOG_HEXDUMP_INFO( gap_adv_data.adv_data.p_data, gap_adv_data.adv_data.len);\n        gap_adv_data.scan_rsp_data.p_data = m_enc_scanrsp;\n        gap_adv_data.scan_rsp_data.len = BLE_GAP_ADV_SET_DATA_SIZE_MAX;\n        MICROBIT_BLE_ECHK(ble_advdata_encode(p_scanrsp, gap_adv_data.scan_rsp_data.p_data, &gap_adv_data.scan_rsp_data.len));\n        // NRF_LOG_HEXDUMP_INFO( gap_adv_data.scan_rsp_data.p_data, gap_adv_data.scan_rsp_data.len);\n        MICROBIT_BLE_ECHK(sd_ble_gap_adv_set_configure(&m_adv_handle, &gap_adv_data, &gap_adv_params));\n    }\n\n    // Setup advertising.\n    // https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L478\n\n    // static void microbit_ble_configureAdvertising( bool, bool, bool, uint16_t, int, ble_uuid_t *)\n    // https://github.com/lancaster-university/codal-microbit-v2/blob/master/source/bluetooth/MicroBitBLEManager.cpp#L1218\n\n    void resetAdvertising(const ManagedString &gapName, const uint16_t serviceUUID)\n    {\n        // Stop\n        uBit.bleManager.stopAdvertising();\n\n        // [Advertising] Complete local name\n        ble_gap_conn_sec_mode_t sec_mode;\n        memset(&sec_mode, 0, sizeof(sec_mode));\n        BLE_GAP_CONN_SEC_MODE_SET_OPEN(&sec_mode);\n        MICROBIT_BLE_ECHK(sd_ble_gap_device_name_set(&sec_mode, (const uint8_t *)gapName.toCharArray(), gapName.length()));\n\n        // [Scan Response] Complete list of 16-bit Service IDs.\n        static ble_uuid_t uuid;\n        uuid.type = BLE_UUID_TYPE_BLE;\n        uuid.uuid = serviceUUID;\n\n        // Configure\n        bool connectable = true;\n        bool discoverable = true;\n        bool whitelist = false;\n\n#if CONFIG_ENABLED(MICROBIT_BLE_WHITELIST)\n        // Configure a whitelist to filter all connection requetss from unbonded devices.\n        // Most BLE stacks only permit one connection at a time, so this prevents denial of service attacks.\n        //    ble->gap().setScanningPolicyMode(Gap::SCAN_POLICY_IGNORE_WHITELIST);\n        //    ble->gap().setAdvertisingPolicyMode(Gap::ADV_POLICY_FILTER_CONN_REQS);\n\n        pm_peer_id_t peer_list[MICROBIT_BLE_MAXIMUM_BONDS];\n        uint32_t list_size = MICROBIT_BLE_MAXIMUM_BONDS;\n        MICROBIT_BLE_ECHK(pm_peer_id_list(peer_list, &list_size, PM_PEER_ID_INVALID, PM_PEER_ID_LIST_ALL_ID));\n        // MICROBIT_BLE_ECHK( pm_whitelist_set( list_size ? peer_list : NULL, list_size));\n        // MICROBIT_BLE_ECHK( pm_device_identities_list_set( list_size ? peer_list : NULL, list_size));\n        connectable = discoverable = whitelist = list_size > 0;\n        MICROBIT_DEBUG_DMESG(\"whitelist size = %d\", list_size);\n#endif\n\n        // adv_data\n        ble_advdata_t advdata;\n        memset(&advdata, 0, sizeof(advdata));\n        advdata.name_type = BLE_ADVDATA_FULL_NAME;\n        advdata.flags = !whitelist && discoverable\n                            ? BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED | BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE\n                            : BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED;\n        // scan_rsp_data\n        ble_advdata_t scanrsp;\n        memset(&scanrsp, 0, sizeof(scanrsp));\n        // advdata.name_type = BLE_ADVDATA_NO_NAME;\n        scanrsp.uuids_complete.p_uuids = &uuid;\n        scanrsp.uuids_complete.uuid_cnt = 1;\n        // configure\n        custom_microbit_ble_configureAdvertising(connectable, discoverable, whitelist,\n                                                 MICROBIT_BLE_ADVERTISING_INTERVAL, MICROBIT_BLE_ADVERTISING_TIMEOUT,\n                                                 &advdata, &scanrsp);\n\n        // Restart\n        uBit.bleManager.advertise();\n    }\n\n#else // MICROBIT_CODAL\n\n    void resetAdvertising(const ManagedString &gapName, const uint16_t serviceUUID)\n    {\n        uBit.ble->stopAdvertising();\n        // [Advertising] Complete local name\n        uBit.ble->accumulateAdvertisingPayload(GapAdvertisingData::COMPLETE_LOCAL_NAME, (uint8_t *)gapName.toCharArray(), gapName.length());\n        // [Scan Response] Complete list of 16-bit Service IDs.\n        uBit.ble->accumulateScanResponse(GapAdvertisingData::COMPLETE_LIST_16BIT_SERVICE_IDS, (uint8_t *)&serviceUUID, 2);\n        uBit.ble->startAdvertising();\n    }\n\n#endif // MICROBIT_CODAL\n}\n","src/customlib.h":"#ifndef CUSTOMLIB_H\n#define CUSTOMLIB_H\n\n#include \"pxt.h\"\n\nnamespace customlib\n{\n    void resetAdvertising(const ManagedString &gapName, const uint16_t serviceUUID);\n}\n\n#endif // #ifndef CUSTOMLIB_H\n","test/test.ts":"/**\n * tests go here; this will not be compiled when this package is used as an extension.\n */\nMbitMore.setBibNumber(123)\n"}